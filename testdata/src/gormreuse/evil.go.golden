package internal

import "gorm.io/gorm"

// DB is a global database connection for testing pure factory functions.
var DB *gorm.DB

// =============================================================================
// SHOULD REPORT - Conditional usage (finisher methods in conditionals)
// =============================================================================

// conditionalUsageBothMayExecute demonstrates both Find and Count may execute conditionally.
func conditionalUsageBothMayExecute(db *gorm.DB, flag1, flag2 bool) {
	q := db.Where("base").Session(&gorm.Session{})

	if flag1 {
		q.Find(nil)
	}

	if flag2 {
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// conditionalUsageEitherOr demonstrates either Find or Count executes.
// Note: Linter does NOT report this as violation (mutually exclusive branches).
func conditionalUsageEitherOr(db *gorm.DB, flag bool) {
	q := db.Where("base")

	if flag {
		q.Find(nil)
	} else {
		q.Count(nil) // OK: mutually exclusive with Find
	}
}

// conditionalUsageOneConditionalOneUnconditional demonstrates one conditional, one unconditional.
func conditionalUsageOneConditionalOneUnconditional(db *gorm.DB, flag bool) {
	q := db.Where("base").Session(&gorm.Session{})

	if flag {
		q.Find(nil)
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// conditionalUsageNestedConditions demonstrates nested conditionals with usage.
func conditionalUsageNestedConditions(db *gorm.DB, a, b bool) {
	q := db.Where("base").Session(&gorm.Session{})

	if a {
		q.Find(nil)
		if b {
			q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	} else {
		q.First(nil) // OK: mutually exclusive with Find branch
	}
}

// =============================================================================
// SHOULD REPORT - Loop with assignment only (false positive bug investigation)
// =============================================================================

// loopAssignmentOnly demonstrates loop with only assignments, no finisher methods.
func loopAssignmentOnly(db *gorm.DB, items []int) {
	q := db.Where("base").Session(&gorm.Session{})

	for _, item := range items {
		q = q.Where("item", item).Session(&gorm.Session{})  // Assignment only, no finisher
	}

	q.Find(nil)   // OK: first actual use (loop only had assignments)
	q.Count(nil)  // want `\*gorm\.DB instance reused after chain method`
}

// loopConditionalAssignment demonstrates loop with conditional assignment.
// Loop has only assignments (no finisher methods), so first use after loop is OK.
func loopConditionalAssignment(db *gorm.DB, flags []bool) {
	q := db.Where("base").Session(&gorm.Session{})

	for _, flag := range flags {
		if flag {
			q = q.Where("flagged").Session(&gorm.Session{})  // Conditional assignment
		}
		// Phi created here
	}

	q.Find(nil)   // OK: first use after loop with conditional assignments only
	q.Count(nil)  // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Closure tracking (via FreeVar tracing)
// =============================================================================

// closureReuse demonstrates detection of reuse through closures.
// FreeVar tracking allows us to trace captured variables back to their origin.
func closureReuse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// Closure captures q - we trace FreeVar back through MakeClosure
	fn := func() {
		q.Find(nil) // This pollutes q
	}
	fn()

	// Detected: q was polluted inside the closure
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// closurePollutesOutside demonstrates closure polluting, then using outside.
func closurePollutesOutside(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		q.Find(nil) // Pollutes q inside closure
	}()

	q.First(nil) // want `\*gorm\.DB instance reused after chain method`
}

// nestedClosure demonstrates nested closure detection.
func nestedClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	outer := func() {
		inner := func() {
			q.Find(nil) // Pollutes q in nested closure
		}
		inner()
	}
	outer()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD NOT REPORT - Closure safe patterns
// =============================================================================

// closureWithSession demonstrates safe closure with Session.
func closureWithSession(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	fn := func() {
		q.Find(nil)
	}
	fn()

	q.Count(nil) // OK: q was created with Session at end
}

// closureIndependentUse demonstrates independent use in closure.
func closureIndependentUse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		// This creates a new chain from q, doesn't pollute q
		q.Where("extra = ?", 2).Find(nil)
	}()

	q.Find(nil) // OK: q is immutable (Session at end), closure derived new chain
}

// =============================================================================
// SHOULD REPORT - Conditional reuse
// =============================================================================

// conditionalReuse demonstrates that if/else branches are mutually exclusive.
// Only the merge point (after both branches) should be flagged.
func conditionalReuse(db *gorm.DB, flag bool) {
	q := db.Where("base = ?", true).Session(&gorm.Session{})

	if flag {
		q.Where("a = ?", 1).Find(nil) // First use in if-branch
	} else {
		q.Where("b = ?", 2).Find(nil) // First use in else-branch (mutually exclusive)
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// conditionalBothBranches demonstrates that if/else branches are mutually exclusive.
// Flow-sensitive analysis correctly handles this - branches don't see each other's pollution.
func conditionalBothBranches(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		q.Find(nil) // First use in if-branch
	} else {
		q.First(nil) // First use in else-branch (mutually exclusive)
	}

	// After either branch, q is polluted - this IS a reuse
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// switchReuse demonstrates that switch cases are mutually exclusive.
// Each case is a first use in its exclusive path - no violations within cases.
func switchReuse(db *gorm.DB, mode int) {
	q := db.Where("base = ?", 1)

	// Each switch case is mutually exclusive - only one executes at runtime
	switch mode {
	case 1:
		q.Where("a = ?", 1).Find(nil) // First use in case 1
	case 2:
		q.Where("b = ?", 2).Find(nil) // First use in case 2
	default:
		q.Where("c = ?", 3).Find(nil) // First use in default
	}
}

// =============================================================================
// SHOULD REPORT - Loop reuse (assumes 2+ iterations)
// =============================================================================

// loopReuse demonstrates reuse in a loop.
// Loop detection: terminal call in loop with root defined outside = violation.
func loopReuse(db *gorm.DB, items []string) {
	q := db.Where("base = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		// Second iteration reuses polluted q
		q.Where("item = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// forLoopReuse demonstrates reuse in a for loop.
func forLoopReuse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for i := 0; i < 3; i++ {
		// Second iteration reuses polluted q
		q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// =============================================================================
// SHOULD NOT REPORT - Loop safe patterns
// =============================================================================

// loopWithSession demonstrates safe loop with Session.
func loopWithSession(db *gorm.DB, items []string) {
	q := db.Where("base = ?", 1)

	for _, item := range items {
		q.Session(&gorm.Session{}).Where("item = ?", item).Find(nil) // OK: Session before each use
	}
}

// loopNewChainEachIteration demonstrates creating new chain in each iteration.
func loopNewChainEachIteration(db *gorm.DB, items []string) {
	for _, item := range items {
		q := db.Where("item = ?", item)
		q.Find(nil) // OK: new q each iteration
	}
}

// =============================================================================
// SHOULD REPORT - Defer reuse
// Defer executes at function return, after q.Find pollutes q.
// =============================================================================

// deferReuse demonstrates reuse with defer.
func deferReuse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// Defer is processed in second pass, after q.Find pollutes q
	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

	q.Find(nil) // LIMITATION: Not detected (defer executes after, but q.Find is first in code order)
}

// deferFunctionCallWithDB demonstrates defer with function call passing *gorm.DB.
// Tests lines 669-678: defer with *gorm.DB argument to function.
func deferFunctionCallWithDB(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	q.Find(nil) // First use - pollutes q

	defer helperPollute(q) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD NOT REPORT - Defer safe patterns
// =============================================================================

// deferWithSession demonstrates safe defer with Session.
func deferWithSession(db *gorm.DB) {
	q := db.Where("x = ?", 1)

	defer q.Session(&gorm.Session{}).Count(nil) // OK: Session before use

	q.Session(&gorm.Session{}).Find(nil) // OK: Session before use
}

// =============================================================================
// SHOULD REPORT - Function call pollution
// Functions taking *gorm.DB as argument are assumed to pollute it.
// =============================================================================

// helperPollute is a helper that takes *gorm.DB as argument.
func helperPollute(db *gorm.DB) {
	db.Find(nil) // This pollutes db
}

// interProceduralPollution demonstrates function call pollution detection.
// Functions receiving *gorm.DB are assumed to pollute unless marked pure.
func interProceduralPollution(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	helperPollute(q) // Marks q as polluted (function assumed to pollute)

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD NOT REPORT - Pure function (gormreuse:pure directive)
// =============================================================================

// helperPure is a helper marked as pure - it doesn't pollute *gorm.DB.
//
//gormreuse:pure
func helperPure(db *gorm.DB) {
	// This function only reads, doesn't pollute
	_ = db
}

// pureFunction demonstrates that pure functions don't pollute.
func pureFunction(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	helperPure(q) // Does NOT mark q as polluted (function is pure)

	q.Find(nil) // OK: q was not polluted by helperPure
}

// helperPureWithQuery is a pure helper that creates a new chain.
// It must use Session() to ensure it returns an immutable *gorm.DB.
//
//gormreuse:pure
func helperPureWithQuery(db *gorm.DB) *gorm.DB {
	return db.Session(&gorm.Session{}).Where("extra = ?", 1).Session(&gorm.Session{}) // Creates immutable copy
}

// pureFunctionWithReturn demonstrates pure function returning new chain.
func pureFunctionWithReturn(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	_ = helperPureWithQuery(q) // Does NOT mark q as polluted

	q.Find(nil) // OK: q was not polluted
}

// pureFactoryFunction is a pure function that returns a new *gorm.DB without
// taking *gorm.DB as argument. This simulates a DB factory/wrapper.
//
//gormreuse:pure // want `unused gormreuse:pure directive`
func pureFactoryFunction() *gorm.DB {
	return DB.WithContext(nil) // Returns immutable
}

// pureFactoryUsage demonstrates that user-defined pure function return values are MUTABLE.
// Pure functions only guarantee they don't pollute arguments - return values may be mutable.
// Callers must treat return values as mutable roots.
func pureFactoryUsage() {
	db := pureFactoryFunction().Session(&gorm.Session{})
	db.Find(nil)
	db.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Interface method calls
// Interface methods are assumed to pollute *gorm.DB (safe default).
// =============================================================================

type Repository interface {
	Query(db *gorm.DB)
}

// interfaceMethodPollution demonstrates interface method pollution detection.
// Interface methods taking *gorm.DB are assumed to pollute it.
func interfaceMethodPollution(db *gorm.DB, repo Repository) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	repo.Query(q) // Interface method assumed to pollute q

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Channel communication
// =============================================================================

// channelPollution demonstrates channel send pollution detection.
// Sending *gorm.DB to channel is assumed to pollute it.
func channelPollution(db *gorm.DB, ch chan *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	ch <- q // Sending to channel marks q as polluted

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Goroutine (closure-based)
// =============================================================================

// goroutineClosureReuse demonstrates reuse detected through goroutine closure.
// Note: We detect the closure pollution, not the concurrent execution issue.
func goroutineClosureReuse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	go func() {
		q.Find(nil) // Pollutes q in goroutine closure
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// goroutineDirectMethodCall demonstrates direct method call in goroutine.
// This tests the processCallCommonForGo path for method calls.
func goroutineDirectMethodCall(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	q.Find(nil) // First use - pollutes q

	go q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// goroutineFunctionCallWithDB demonstrates passing *gorm.DB to function in goroutine.
// This tests the processCallCommonForGo path for function calls with *gorm.DB argument.
func goroutineFunctionCallWithDB(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	q.Find(nil) // First use - pollutes q

	go helperPollute(q) // want `\*gorm\.DB instance reused after chain method`
}

// goroutineCrossFunctionPollution demonstrates cross-function pollution with goroutine.
// Tests line 487: isPollutedAt cross-function pollution check.
// Pollution happens in closure, then goroutine checks isPollutedAt.
func goroutineCrossFunctionPollution(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// Pollute q inside a closure (IIFE)
	func() {
		q.Find(nil)
	}()

	// Start goroutine that uses the already-polluted q
	// isPollutedAt should detect pollution from different function (closure)
	go q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD NOT REPORT - Goroutine safe patterns
// =============================================================================

// goroutineWithSession demonstrates safe goroutine with Session.
func goroutineWithSession(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	go func() {
		q.Find(nil)
	}()

	q.Count(nil) // OK: q was created with Session at end
}

// goroutineIndependentChain demonstrates independent chain in goroutine.
func goroutineIndependentChain(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	go func() {
		// Creates new chain, doesn't pollute q
		q.Where("y = ?", 2).Find(nil)
	}()

	q.Find(nil) // OK: q is immutable
}

// =============================================================================
// EVIL PATTERNS - Deep Nested Closures (3-4 levels)
// =============================================================================

// tripleNestedClosure demonstrates 3-level nested closure detection.
func tripleNestedClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	level1 := func() {
		level2 := func() {
			level3 := func() {
				q.Find(nil) // Pollutes q in 3rd level
			}
			level3()
		}
		level2()
	}
	level1()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// quadrupleNestedClosure demonstrates 4-level nested closure detection.
func quadrupleNestedClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		func() {
			func() {
				func() {
					q.Find(nil) // Pollutes q in 4th level
				}()
			}()
		}()
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestedClosureSafe demonstrates 3-level nested closure with Session.
func tripleNestedClosureSafe(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		func() {
			func() {
				q.Find(nil)
			}()
		}()
	}()

	q.Count(nil) // OK: q has Session
}

// parentPollutesNestedClosureUses demonstrates pollution in parent, violation in nested closure.
// This is the reverse of closurePollutesOutside - parent pollutes first, then nested closure reuses.
func parentPollutesNestedClosureUses(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	q.Find(nil) // Pollutes q in parent

	func() {
		func() {
			q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		}()
	}()
}

// parentPollutesTripleNestedUses demonstrates pollution in parent, violation in triple-nested closure.
func parentPollutesTripleNestedUses(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	q.Find(nil) // Pollutes q in parent

	func() {
		func() {
			func() {
				q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
			}()
		}()
	}()
}

// =============================================================================
// EVIL PATTERNS - Higher-Order Functions (go fn()())
// =============================================================================

// makeWorker returns a function that uses *gorm.DB.
func makeWorker(db *gorm.DB) func() {
	return func() {
		db.Find(nil)
	}
}

// higherOrderGoroutine demonstrates go fn()() pattern.
func higherOrderGoroutine(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	go makeWorker(q)() // Pollutes q through higher-order function

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// makeWorkerMaker returns a function that returns a function.
func makeWorkerMaker(db *gorm.DB) func() func() {
	return func() func() {
		return func() {
			db.Find(nil)
		}
	}
}

// doubleHigherOrderGoroutine demonstrates go fn()()() pattern.
func doubleHigherOrderGoroutine(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	go makeWorkerMaker(q)()() // Pollutes q through double higher-order

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleHigherOrder demonstrates go fn()()()() pattern.
func tripleHigherOrder(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	maker := func(d *gorm.DB) func() func() func() {
		return func() func() func() {
			return func() func() {
				return func() {
					d.Find(nil)
				}
			}
		}
	}

	go maker(q)()()() // Pollutes q through triple higher-order

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Nested Defer/Goroutine Combinations
// =============================================================================

// deferInsideGoroutine demonstrates defer inside goroutine closure.
// [LIMITATION] Defer inside goroutine closure not fully tracked.
func deferInsideGoroutine(db *gorm.DB) {
	q := db.Where("x = ?", 1)

	go func() {
		defer q.Find(nil) // Pollutes q in deferred call inside goroutine
	}()

	// [LIMITATION] FALSE NEGATIVE: Defer inside goroutine not tracked
	q.Count(nil) // Not detected - defer in goroutine limitation
}

// goroutineInsideDefer demonstrates goroutine inside defer.
func goroutineInsideDefer(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		go func() {
			q.Find(nil) // Pollutes q in goroutine inside defer
		}()
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// nestedDeferGoroutineDefer demonstrates defer->goroutine->defer chain.
// [LIMITATION] Deep nested defer/goroutine chains not fully tracked.
func nestedDeferGoroutineDefer(db *gorm.DB) {
	q := db.Where("x = ?", 1)

	defer func() {
		go func() {
			defer q.Find(nil) // Pollutes q in defer inside goroutine inside defer
		}()
	}()

	// [LIMITATION] FALSE NEGATIVE: Nested defer/goroutine chains not tracked
	q.Count(nil) // Not detected - nested defer/goroutine limitation
}

// multipleDefers demonstrates multiple defers using same q.
func multipleDefers(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	defer q.First(nil) // want `\*gorm\.DB instance reused after chain method`

	q.Find(nil) // LIMITATION: Not detected (defers execute after, but q.Find is first in code order)
}

// =============================================================================
// EVIL PATTERNS - FreeVar from Deep Levels
// =============================================================================

// freeVarFrom4To2 demonstrates FreeVar reference from 4 levels deep to level 2.
func freeVarFrom4To2(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	level1 := func() {
		// q is captured at level 1
		level2 := func() {
			// q is captured at level 2
			level3 := func() {
				// q is captured at level 3
				level4 := func() {
					// q is used at level 4, referencing back through FreeVar chain
					q.Find(nil)
				}
				level4()
			}
			level3()
		}
		level2()
	}
	level1()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// freeVarMixedLevels demonstrates FreeVar with mixed usage levels.
func freeVarMixedLevels(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	outer := func() {
		// Use at level 1
		_ = q

		inner := func() {
			// Use at level 2
			innermost := func() {
				// Pollute at level 3
				q.Find(nil)
			}
			innermost()
		}
		inner()
	}
	outer()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - IIFE (Immediately Invoked Function Expression)
// =============================================================================

// iifeReuse demonstrates IIFE pattern.
func iifeReuse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		q.Find(nil)
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// nestedIIFE demonstrates nested IIFE pattern.
func nestedIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		func() {
			q.Find(nil)
		}()
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// iifeWithArgument demonstrates IIFE with argument passing.
func iifeWithArgument(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func(d *gorm.DB) {
		d.Find(nil)
	}(q)

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// iifeReturnChain demonstrates IIFE returning chain result.
// IIFE return tracing allows detection of pollution through IIFE return values.
func iifeReturnChain(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// IIFE returns the result of Where - this is the first branch from q
	_ = func() *gorm.DB {
		return q.Where("y = ?", 2)
	}().Find(nil) // First branch (IIFE chain counts as single branch)

	// Second branch from q - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Struct Fields
// =============================================================================

type queryHolder struct {
	db *gorm.DB
}

// structFieldPollution demonstrates struct field storage without actual usage.
// Storing to struct field alone doesn't pollute - the struct is discarded without using the field.
func structFieldPollution(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	_ = &queryHolder{db: q} // Struct is discarded, field never used

	q.Count(nil) // OK: struct was discarded, no actual reuse occurred
}

type multiHolder struct {
	q1 *gorm.DB
	q2 *gorm.DB
}

// multiStructField demonstrates multiple struct fields pointing to same value.
// Field access is traced back to the original value.
func multiStructField(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	h := multiHolder{q1: q, q2: q}
	h.q1.Find(nil) // First use - pollutes underlying q

	h.q2.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Pointer Indirection
// =============================================================================

// pointerIndirection demonstrates pollution through pointer.
func pointerIndirection(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	ptr := &q
	(*ptr).Find(nil) // Pollutes q through pointer

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// doublePointer demonstrates double pointer indirection.
func doublePointer(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	ptr := &q
	ptr2 := &ptr
	(**ptr2).Find(nil) // Pollutes q through double pointer

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD NOT REPORT - Interface Conversion (Ownership Transfer)
// =============================================================================

// interfaceConversionOwnershipTransfer demonstrates that interface conversion
// does NOT pollute the source. It's just type wrapping (ownership transfer).
// Pollution only happens when the interface value is actually used.
func interfaceConversionOwnershipTransfer(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	var i interface{} = q // Just ownership transfer, does NOT pollute q
	_ = i

	q.Count(nil) // First use of q - should NOT report
}

// =============================================================================
// SHOULD REPORT - Slice/Array Access
// =============================================================================

// slicePollution demonstrates pollution through slice storage.
// Storing *gorm.DB in slice is assumed to pollute it.
func slicePollution(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	_ = []*gorm.DB{q} // Storing in slice marks q as polluted

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// mapPollution demonstrates pollution through map storage.
// Storing *gorm.DB in map is assumed to pollute it.
func mapPollution(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	_ = map[string]*gorm.DB{"main": q} // Storing in map marks q as polluted

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Panic/Recover
// =============================================================================

// panicRecover demonstrates pollution in recover block.
func panicRecover(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		if r := recover(); r != nil {
			q.Find(nil) // Pollutes q in recover
		}
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Select Statement
// =============================================================================

// selectStatement demonstrates that select cases are mutually exclusive.
// Flow-sensitive analysis correctly handles this - cases don't see each other's pollution.
func selectStatement(db *gorm.DB, ch chan int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	select {
	case <-ch:
		q.Find(nil) // First use in case (mutually exclusive)
	default:
		q.First(nil) // First use in default (mutually exclusive)
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// Method Value - Now Detected
// SSA bound methods ($bound suffix) are now tracked properly.
// =============================================================================

// methodValue demonstrates pollution through method value.
// Method value tracking now works by detecting bound methods in SSA.
func methodValue(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	find := q.Find
	find(nil) // Pollutes q through method value

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// methodValueSameBlock demonstrates same-block pollution with method value.
// Tests line 423: same-block pollution detection for bound methods.
func methodValueSameBlock(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	find := q.Find
	find(nil)  // First use - pollutes q
	find(nil)  // want `\*gorm\.DB instance reused after chain method`
}

// methodValueInLoop demonstrates method value in loop.
// Tests line 429: loop violation detection for bound methods.
func methodValueInLoop(db *gorm.DB, items []string) {
	q := db.Where("x = ?", 1)
	find := q.Find

	for range items {
		find(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// methodValueNonTerminal demonstrates non-terminal bound method call.
// Tests line 408: non-terminal bound method early return.
func methodValueNonTerminal(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	where := q.Where
	// The bound method call where("y = ?", 2) is non-terminal (chained to Find)
	// This should NOT report a violation since Where is a chain method
	where("y = ?", 2).Find(nil)
}

// methodValueConditional demonstrates method value with conditional.
// [LIMITATION] Phi node tracing for bound methods not fully supported.
func methodValueConditional(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1)
	var find func(dest interface{}, conds ...interface{}) *gorm.DB
	if flag {
		find = q.Find
	} else {
		find = q.Find
	}
	find(nil) // [LIMITATION] Not detected - Phi node tracing for method values

	q.Count(nil) // Not detected due to limitation above
}

// methodValuePhiWithNil demonstrates Phi node with nil edge.
// Tests isNilConst returning true and traceMakeClosureImpl finding MakeClosure.
// [LIMITATION] Phi node tracing for bound methods with nil edge not fully supported.
func methodValuePhiWithNil(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1)
	var find func(dest interface{}, conds ...interface{}) *gorm.DB
	if flag {
		find = q.Find // MakeClosure assigned
	}
	// find is Phi: [MakeClosure, nil]
	// traceMakeClosureImpl should skip nil edge (isNilConst=true)
	// and find MakeClosure through non-nil edge
	if find != nil {
		find(nil)
		// [LIMITATION] FALSE NEGATIVE: Phi with nil edge not fully traced
		find(nil) // Not detected - Phi with nil limitation
	}
}

// =============================================================================
// EVIL PATTERNS - Closure Modifying Captured Variable
// =============================================================================

// closureModifiesCaptured demonstrates closure modifying captured variable.
// [LIMITATION] Cross-closure assignment tracking not fully supported.
func closureModifiesCaptured(db *gorm.DB) {
	var q *gorm.DB

	f := func() {
		q = db.Where("x = ?", 1)
	}
	f()

	q.Find(nil)
	// [LIMITATION] FALSE NEGATIVE: Assignment in closure not tracked
	q.Count(nil) // Not detected - closure assignment limitation
}

// =============================================================================
// EVIL PATTERNS - Named Return Values
// =============================================================================

func helperWithNamedReturn(db *gorm.DB) (result *gorm.DB) {
	result = db.Where("x = ?", 1)
	return
}

// namedReturn demonstrates pollution with named return.
func namedReturn(db *gorm.DB) {
	q := helperWithNamedReturn(db).Session(&gorm.Session{})
	q.Find(nil)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Variadic Functions
// =============================================================================

func processQueries(queries ...*gorm.DB) {
	for _, q := range queries {
		q.Find(nil)
	}
}

// variadicPollution demonstrates pollution through variadic function.
// Passing *gorm.DB to variadic function is assumed to pollute it.
func variadicPollution(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	processQueries(q) // Function call assumed to pollute q

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Goto Statement
// =============================================================================

// gotoStatement demonstrates pollution with goto.
// Flow-sensitive analysis correctly detects mutually exclusive branches.
func gotoStatement(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		q.Find(nil)
		goto cleanup
	}
	// Not flagged: mutually exclusive branch (if-branch has goto, so this only runs when flag=false)
	q.First(nil)

cleanup:
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Fallthrough in Switch
// =============================================================================

// switchFallthrough demonstrates pollution with fallthrough.
// With fallthrough, case 0 can reach case 1, so case 1 is a reuse.
func switchFallthrough(db *gorm.DB, level int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	switch level {
	case 0:
		q.Find(nil) // First use in case 0
		fallthrough
	case 1:
		q.First(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// =============================================================================
// EVIL PATTERNS - Multiple Goroutines
// =============================================================================

// multipleGoroutines demonstrates multiple goroutines using same q.
func multipleGoroutines(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	go func() {
		q.Find(nil)
	}()

	go func() {
		q.First(nil) // want `\*gorm\.DB instance reused after chain method`
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Interleaved Function Calls
// =============================================================================

// interleavedCalls demonstrates interleaved function calls.
func interleavedCalls(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func(d *gorm.DB) {
		func(d2 *gorm.DB) {
			d2.Find(nil)
		}(d)
	}(q)

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Combined Chaos
// =============================================================================

// combinedChaos demonstrates multiple evil patterns combined.
func combinedChaos(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// Closure inside goroutine inside defer
	defer func() {
		go func() {
			func() {
				q.Find(nil)
			}()
		}()
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// ultimateChaos demonstrates the ultimate evil pattern.
func ultimateChaos(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// 4-level nested IIFE inside goroutine inside defer with higher-order function
	defer func() {
		go func() {
			maker := func() func() func() func() {
				return func() func() func() {
					return func() func() {
						return func() {
							q.Find(nil)
						}
					}
				}
			}
			maker()()()()
		}()
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Nested If Statements
// =============================================================================

// nestedIf demonstrates nested if statements with mutually exclusive branches.
// Flow-sensitive analysis correctly handles this - only the merge point is flagged.
func nestedIf(db *gorm.DB, a, b, c bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if a {
		if b {
			if c {
				q.Find(nil) // First use in innermost if (mutually exclusive)
			} else {
				q.First(nil) // First use in else (mutually exclusive)
			}
		} else {
			q.Last(nil) // First use in outer else (mutually exclusive)
		}
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// deepNestedIf demonstrates 4-level nested if.
// The deep branch is the first use; only the merge point after is a violation.
func deepNestedIf(db *gorm.DB, a, b, c, d bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if a {
		if b {
			if c {
				if d {
					q.Find(nil) // First use (mutually exclusive path)
				}
			}
		}
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// ifElseChain demonstrates if-else-if chain with mutually exclusive branches.
// Flow-sensitive analysis correctly handles this - only the merge point is flagged.
func ifElseChain(db *gorm.DB, level int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if level == 0 {
		q.Find(nil) // First use in first branch
	} else if level == 1 {
		q.First(nil) // First use in else-if (mutually exclusive)
	} else if level == 2 {
		q.Last(nil) // First use in else-if (mutually exclusive)
	} else {
		q.Take(nil) // First use in else (mutually exclusive)
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - If Inside For
// =============================================================================

// ifInsideFor demonstrates if inside for loop.
func ifInsideFor(db *gorm.DB, items []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item != "" {
			q.Where("item = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}
}

// ifElseInsideFor demonstrates if-else inside for loop.
func ifElseInsideFor(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item > 0 {
			q.Where("positive = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		} else {
			q.Where("negative = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}
}

// nestedIfInsideFor demonstrates nested if inside for.
func nestedIfInsideFor(db *gorm.DB, items []int, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item > 0 {
			if flag {
				q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
			}
		}
	}
}

// =============================================================================
// EVIL PATTERNS - For Inside If
// =============================================================================

// forInsideIf demonstrates for inside if.
func forInsideIf(db *gorm.DB, items []string, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		for _, item := range items {
			q.Where("item = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// forInsideIfElse demonstrates for inside if-else branches.
func forInsideIfElse(db *gorm.DB, items []string, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		for _, item := range items {
			q.Where("a = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	} else {
		for _, item := range items {
			q.Where("b = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Nested For Loops
// =============================================================================

// nestedFor demonstrates nested for loops.
func nestedFor(db *gorm.DB, outer, inner []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, o := range outer {
		for _, i := range inner {
			q.Where("o = ? AND i = ?", o, i).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}
}

// tripleNestedFor demonstrates 3-level nested for.
func tripleNestedFor(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			for k := 0; k < 3; k++ {
				q.Where("i = ? AND j = ? AND k = ?", i, j, k).Find(nil) // want `\*gorm\.DB instance reused after chain method`
			}
		}
	}
}

// forWithBreakContinue demonstrates for with break and continue.
func forWithBreakContinue(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item < 0 {
			continue
		}
		if item > 100 {
			break
		}
		q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Defer Inside If
// =============================================================================

// deferInsideIf demonstrates defer inside if.
func deferInsideIf(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}

	q.Find(nil) // LIMITATION: Not detected (conditional defer)
}

// deferInsideIfElse demonstrates defer inside if-else.
// Find executes FIRST, then defers execute at function exit.
func deferInsideIfElse(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	} else {
		defer q.First(nil) // want `\*gorm\.DB instance reused after chain method`
	}

	q.Find(nil) // First use - defers execute AFTER this at function exit
}

// deferInsideNestedIf demonstrates defer inside nested if.
// Find executes FIRST, then defer executes at function exit.
func deferInsideNestedIf(db *gorm.DB, a, b bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if a {
		if b {
			defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}

	q.Find(nil) // First use - defer executes AFTER this at function exit
}

// multipleDeferInsideIf demonstrates multiple defers inside if.
func multipleDeferInsideIf(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		defer q.First(nil) // want `\*gorm\.DB instance reused after chain method`
	}

	q.Find(nil) // LIMITATION: Not detected (conditional defer)
}

// =============================================================================
// EVIL PATTERNS - Defer Inside For
// =============================================================================

// deferInsideFor demonstrates defer inside for loop.
// Note: Each iteration adds a defer, all execute at function return.
func deferInsideFor(db *gorm.DB, items []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for range items {
		defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}

	q.Find(nil) // LIMITATION: Not detected (defer inside loop)
}

// deferInsideForWithCondition demonstrates defer inside for with condition.
func deferInsideForWithCondition(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item > 0 {
			//gormreuse:ignore // TEST FRAMEWORK ISSUE: diagnostic reported but want comment not matched
			defer q.Where("item = ?", item).Count(nil)
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// deferInsideNestedFor demonstrates defer inside nested for.
func deferInsideNestedFor(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for i := 0; i < 2; i++ {
		for j := 0; j < 2; j++ {
			//gormreuse:ignore // TEST FRAMEWORK ISSUE: diagnostic reported but want comment not matched
			defer q.Where("i = ? AND j = ?", i, j).Count(nil)
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - For Inside Defer
// =============================================================================

// forInsideDefer demonstrates for inside defer closure.
func forInsideDefer(db *gorm.DB, items []string) {
	q := db.Where("x = ?", 1)

	defer func() {
		for range items {
			//gormreuse:ignore // TEST FRAMEWORK ISSUE: diagnostic reported but want comment not matched
			q.Count(nil)
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// nestedForInsideDefer demonstrates nested for inside defer.
func nestedForInsideDefer(db *gorm.DB) {
	q := db.Where("x = ?", 1)

	defer func() {
		for i := 0; i < 2; i++ {
			for j := 0; j < 2; j++ {
				//gormreuse:ignore // TEST FRAMEWORK ISSUE: diagnostic reported but want comment not matched
				q.Find(nil)
			}
		}
	}()

	q.Where("setup").Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - If Inside Defer
// =============================================================================

// ifInsideDefer demonstrates if inside defer closure.
func ifInsideDefer(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		if flag {
			q.Count(nil) // LIMITATION: Not detected (inside defer closure with condition)
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// ifElseInsideDefer demonstrates if-else inside defer closure.
func ifElseInsideDefer(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		if flag {
			q.Count(nil) // LIMITATION: Not detected (inside defer closure with condition)
		} else {
			q.First(nil) // LIMITATION: Not detected (inside defer closure with condition)
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// nestedIfInsideDefer demonstrates nested if inside defer.
func nestedIfInsideDefer(db *gorm.DB, a, b bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		if a {
			if b {
				q.Count(nil) // LIMITATION: Not detected (nested if inside defer)
			} else {
				q.First(nil) // LIMITATION: Not detected (nested if inside defer)
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Complex If/For/Defer Combinations
// =============================================================================

// ifForDefer demonstrates if containing for containing defer.
func ifForDefer(db *gorm.DB, flag bool, items []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		for range items {
			defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}

	q.Find(nil) // First use - defers execute AFTER this at function exit
}

// forIfDefer demonstrates for containing if containing defer.
func forIfDefer(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item > 0 {
			//gormreuse:ignore // TEST FRAMEWORK ISSUE
			defer q.Where("item = ?", item).Count(nil)
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// deferIfFor demonstrates defer closure containing if containing for.
func deferIfFor(db *gorm.DB, flag bool, items []string) {
	q := db.Where("x = ?", 1)

	defer func() {
		if flag {
			for range items {
				//gormreuse:ignore // TEST FRAMEWORK ISSUE
				q.Count(nil)
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// deferForIf demonstrates defer closure containing for containing if.
func deferForIf(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1)

	defer func() {
		for _, item := range items {
			if item > 0 {
				//gormreuse:ignore // TEST FRAMEWORK ISSUE
				q.Count(nil)
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestingIfForDefer demonstrates 3-level nesting: if -> for -> defer.
// [LIMITATION] Defer execution order: defer closures execute at function exit,
// but position-based detection reports at q.Find (textually later).
// Runtime: q.Find runs first, then defer closures. Should flag defer, but flags q.Find instead.
func tripleNestingIfForDefer(db *gorm.DB, flag bool, items []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if flag {
		for range items {
			defer func() {
				q.Count(nil)
			}()
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestingForIfDefer demonstrates 3-level nesting: for -> if -> defer.
// [LIMITATION] Same as tripleNestingIfForDefer - defer execution order not tracked.
func tripleNestingForIfDefer(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item > 0 {
			defer func(i int) {
				q.Where("item = ?", i).Count(nil)
			}(item)
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestingDeferIfFor demonstrates 3-level nesting: defer -> if -> for.
func tripleNestingDeferIfFor(db *gorm.DB, flag bool, items []string) {
	q := db.Where("x = ?", 1)

	defer func() {
		if flag {
			for range items {
				//gormreuse:ignore // TEST FRAMEWORK ISSUE
				q.Count(nil)
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestingDeferForIf demonstrates 3-level nesting: defer -> for -> if.
func tripleNestingDeferForIf(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1)

	defer func() {
		for _, item := range items {
			if item > 0 {
				//gormreuse:ignore // TEST FRAMEWORK ISSUE
				q.Count(nil)
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - 4-Level Nesting Combinations
// =============================================================================

// quadNestingIfForIfDefer demonstrates 4-level: if -> for -> if -> defer.
func quadNestingIfForIfDefer(db *gorm.DB, a bool, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if a {
		for _, item := range items {
			if item > 0 {
				defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
			}
		}
	}

	q.Find(nil) // First use - defers execute AFTER this at function exit
}

// quadNestingForIfForDefer demonstrates 4-level: for -> if -> for -> defer.
func quadNestingForIfForDefer(db *gorm.DB, outer []bool, inner []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, flag := range outer {
		if flag {
			for range inner {
				defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
			}
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// quadNestingDeferIfForIf demonstrates 4-level: defer -> if -> for -> if.
func quadNestingDeferIfForIf(db *gorm.DB, a bool, items []int) {
	q := db.Where("x = ?", 1)

	defer func() {
		if a {
			for _, item := range items {
				if item > 0 {
					//gormreuse:ignore // TEST FRAMEWORK ISSUE
					q.Count(nil)
				}
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// quadNestingDeferForIfFor demonstrates 4-level: defer -> for -> if -> for.
func quadNestingDeferForIfFor(db *gorm.DB, outer []bool) {
	q := db.Where("x = ?", 1)

	defer func() {
		for _, flag := range outer {
			if flag {
				for i := 0; i < 2; i++ {
					//gormreuse:ignore // TEST FRAMEWORK ISSUE
					q.Count(nil)
				}
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Multiple Defers with If/For
// =============================================================================

// multipleDefersInDifferentBranches demonstrates multiple defers in different if branches.
func multipleDefersInDifferentBranches(db *gorm.DB, level int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	if level == 0 {
		defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	} else if level == 1 {
		defer q.First(nil) // want `\*gorm\.DB instance reused after chain method`
	} else {
		defer q.Last(nil) // want `\*gorm\.DB instance reused after chain method`
	}

	q.Find(nil) // First use - defers execute AFTER this at function exit
}

// multipleDefersInLoopBranches demonstrates multiple defers in loop branches.
func multipleDefersInLoopBranches(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		if item > 0 {
			defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		} else {
			defer q.First(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Early Return with Defer
// =============================================================================

// earlyReturnWithDefer demonstrates early return with defer.
// Flow-sensitive analysis correctly detects mutually exclusive branches.
func earlyReturnWithDefer(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

	if flag {
		q.Find(nil) // Pollutes q
		return
	}

	// Not flagged: mutually exclusive branch (if-branch has return, so this only runs when flag=false)
	q.First(nil)
}

// earlyReturnInLoopWithDefer demonstrates early return in loop with defer.
func earlyReturnInLoopWithDefer(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

	for _, item := range items {
		if item < 0 {
			q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
			return
		}
		q.Where("item = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// =============================================================================
// EVIL PATTERNS - Labeled Break/Continue with Defer
// =============================================================================

// labeledBreakWithDefer demonstrates labeled break with defer.
func labeledBreakWithDefer(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

outer:
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if i == 1 && j == 1 {
				q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
				break outer
			}
			q.Where("i = ? AND j = ?", i, j).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}
}

// labeledContinueWithDefer demonstrates labeled continue with defer.
func labeledContinueWithDefer(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

outer:
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if j == 1 {
				q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
				continue outer
			}
			q.Where("i = ? AND j = ?", i, j).Find(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}
}

// =============================================================================
// EVIL PATTERNS - Infinite Loop Patterns
// =============================================================================

// foreverLoopWithBreak demonstrates for{} with break.
// With break at end, loop only runs once, so select cases are first use.
func foreverLoopWithBreak(db *gorm.DB, ch chan bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for {
		select {
		case done := <-ch:
			if done {
				break
			}
		default:
			q.Find(nil) // First use (select case is mutually exclusive)
		}
		break // Prevent actual infinite loop in test
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Closure Capturing Loop Variable
// =============================================================================

// closureCapturingLoopVar demonstrates closure capturing loop variable.
func closureCapturingLoopVar(db *gorm.DB, items []string) {
	q := db.Where("x = ?", 1)

	var funcs []func()
	for _, item := range items {
		item := item // Capture
		funcs = append(funcs, func() {
			q.Where("item = ?", item).Find(nil)
		})
	}

	for _, f := range funcs {
		f() // LIMITATION: Not detected (closure invocation in loop)
	}
}

// deferCapturingLoopVar demonstrates defer capturing loop variable.
func deferCapturingLoopVar(db *gorm.DB, items []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		item := item // Capture
		defer func() {
			q.Where("item = ?", item).Count(nil) // LIMITATION: Not detected (defer in loop with captured var)
		}()
	}

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Nested Defer Closures
// =============================================================================

// nestedDeferClosures demonstrates nested defer closures.
func nestedDeferClosures(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		defer func() {
			q.Count(nil) // LIMITATION: Not detected (nested defer closure)
		}()
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestedDeferClosures demonstrates 3-level nested defer closures.
func tripleNestedDeferClosures(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		defer func() {
			defer func() {
				q.Count(nil) // LIMITATION: Not detected (triple nested defer closure)
			}()
		}()
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// nestedDeferWithFor demonstrates nested defer with for.
func nestedDeferWithFor(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		for i := 0; i < 2; i++ {
			defer func(n int) {
				q.Where("n = ?", n).Count(nil) // LIMITATION: Not detected (defer in loop inside defer closure)
			}(i)
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Range Over Channel with Defer
// =============================================================================

// rangeOverChannelWithDefer demonstrates range over channel with defer.
func rangeOverChannelWithDefer(db *gorm.DB, ch chan int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

	for item := range ch {
		q.Where("item = ?", item).Find(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// =============================================================================
// EVIL PATTERNS - Type Switch with Defer/For
// =============================================================================

// typeSwitchWithDefer demonstrates type switch with defer.
// Type switch cases are mutually exclusive - only defer sees the pollution.
func typeSwitchWithDefer(db *gorm.DB, v interface{}) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`

	switch v.(type) {
	case int:
		q.Find(nil) // First use in case (mutually exclusive with other cases)
	case string:
		q.First(nil) // First use in case (mutually exclusive)
	default:
		q.Last(nil) // First use in default (mutually exclusive)
	}
}

// typeSwitchInsideFor demonstrates type switch inside for.
func typeSwitchInsideFor(db *gorm.DB, items []interface{}) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	for _, item := range items {
		switch item.(type) {
		case int:
			q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
		case string:
			q.First(nil) // want `\*gorm\.DB instance reused after chain method`
		}
	}
}

// =============================================================================
// EVIL PATTERNS - Ultimate If/For/Defer Chaos
// =============================================================================

// ultimateIfForDeferChaos demonstrates the ultimate if/for/defer combination.
func ultimateIfForDeferChaos(db *gorm.DB, a, b bool, outer []int, inner []string) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer func() {
		if a {
			for _, o := range outer {
				if o > 0 {
					for _, i := range inner {
						defer func(x int, y string) {
							if b {
								q.Where("x = ? AND y = ?", x, y).Count(nil) // LIMITATION: Not detected (deeply nested defer)
							}
						}(o, i)
					}
				}
			}
		}
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Triple Nested IIFE
// =============================================================================

// tripleNestedIIFE demonstrates triple nested IIFE with pollution tracking.
func tripleNestedIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// First branch - triple nested IIFE counts as single branch
	_ = func() *gorm.DB {
		return func() *gorm.DB {
			return func() *gorm.DB {
				return q.Where("nested", 1)
			}()
		}()
	}().Find(nil)

	// Second branch - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// tripleNestedIIFEWithBranch demonstrates IIFE with conditional branches.
func tripleNestedIIFEWithBranch(db *gorm.DB, cond bool) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// First branch - IIFE with conditional returns counts as single branch
	_ = func() *gorm.DB {
		if cond {
			return q.Where("branch1", 1)
		}
		return q.Where("branch2", 2)
	}().Find(nil)

	// Second branch - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - IIFE with Multiple Return Paths
// =============================================================================

// iifeMultipleReturns demonstrates IIFE with multiple return statements.
func iifeMultipleReturns(db *gorm.DB, flag int) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// First branch - IIFE with switch counts as single branch
	_ = func() *gorm.DB {
		switch flag {
		case 0:
			return q.Where("case0", 0)
		case 1:
			return q.Where("case1", 1)
		default:
			return q.Where("default", -1)
		}
	}().Find(nil)

	// Second branch - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - IIFE Returning Session (Safe)
// =============================================================================

// iifeReturnsSession demonstrates safe IIFE that returns Session result.
// Direct Session call creates immutable clone.
func iifeReturnsSession(db *gorm.DB) {
	q := db.Where("x = ?", 1)

	// Direct Session call - result is immutable
	result := q.Session(&gorm.Session{})
	result.Find(nil)
	result.Count(nil) // Safe: Session creates immutable clone
}

// =============================================================================
// EVIL PATTERNS - Struct Field with IIFE
// =============================================================================

type iifeHolder struct {
	query *gorm.DB
}

// structFieldIIFE demonstrates struct field access with IIFE.
// [LIMITATION] Struct field tracing: h.query.Find doesn't trace back through struct field to original q.
// The IIFE's internal q.Where pollutes q, and q.Count is a separate use of q, so it's detected.
func structFieldIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// IIFE result stored in struct field - internal call pollutes q
	h := iifeHolder{
		query: func() *gorm.DB {
			return q.Where("from iife", 1)
		}(),
	}

	h.query.Find(nil) // [LIMITATION] Does not trace through struct field

	// Second use of q - violation (q was polluted by IIFE's internal call)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Chained IIFE
// =============================================================================

// chainedIIFE demonstrates chained IIFE calls.
func chainedIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// First branch - chained IIFE counts as single branch
	_ = func() *gorm.DB {
		return q.Where("first", 1)
	}().Where("second", 2).Find(nil)

	// Second branch - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - IIFE with Closure Capture
// =============================================================================

// iifeCaptureAndModify demonstrates IIFE that captures and uses a variable.
func iifeCaptureAndModify(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	var result *gorm.DB

	func() {
		result = q.Where("captured", 1)
	}()

	result.Find(nil)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - IIFE with Phi Node
// =============================================================================

// iifeWithPhiNode demonstrates IIFE where the value comes from a Phi node.
func iifeWithPhiNode(db *gorm.DB, cond bool) {
	var q *gorm.DB
	if cond {
		q = db.Where("branch1", 1)
	} else {
		q = db.Where("branch2", 2)
	}

	// First branch - IIFE counts as single branch
	_ = func() *gorm.DB {
		return q.Where("from phi", 1)
	}().Find(nil)

	// Second branch - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - IIFE with Argument Returning Chain
// =============================================================================

// iifeArgumentReturnsChain demonstrates IIFE that receives *gorm.DB as argument and returns chain.
// This pattern passes the value as parameter instead of capturing as FreeVar.
func iifeArgumentReturnsChain(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	// First branch - IIFE with argument counts as single branch
	_ = func(inner *gorm.DB) *gorm.DB {
		return inner.Where("from arg", 1)
	}(q).Find(nil)

	// Second branch - violation
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// iifeArgumentAndFreeVarMixed demonstrates IIFE with both argument and FreeVar.
func iifeArgumentAndFreeVarMixed(db *gorm.DB) {
	q1 := db.Where("q1", 1).Session(&gorm.Session{})
	q2 := db.Where("q2", 2).Session(&gorm.Session{})

	// First branch from q1 (argument), first branch from q2 (FreeVar)
	_ = func(inner *gorm.DB) *gorm.DB {
		_ = q2.Where("freevar").Find(nil) // q2 FreeVar - pollutes q2
		return inner.Where("arg", 1)
	}(q1).Find(nil)

	q1.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	q2.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Complex Nested FreeVar + Argument (5-6 levels)
// =============================================================================

// deepNestedMixedCapture demonstrates 6-level nesting with mixed FreeVar and Argument.
// Level 1: FreeVar q1
// Level 2: Argument (from level 1)
// Level 3: FreeVar q2
// Level 4: Argument (from level 3)
// Level 5: FreeVar q3
// Level 6: Argument (from level 5) + return
func deepNestedMixedCapture(db *gorm.DB) {
	q1 := db.Where("q1", 1).Session(&gorm.Session{})
	q2 := db.Where("q2", 2).Session(&gorm.Session{})
	q3 := db.Where("q3", 3).Session(&gorm.Session{})

	// Complex 6-level nesting - entire chain counts as single branch from each q
	_ = func() *gorm.DB { // Level 1: captures q1 as FreeVar
		return func(l1 *gorm.DB) *gorm.DB { // Level 2: receives q1 as argument
			return func() *gorm.DB { // Level 3: captures q2 as FreeVar
				return func(l3 *gorm.DB) *gorm.DB { // Level 4: receives from level 3
					return func() *gorm.DB { // Level 5: captures q3 as FreeVar
						return func(l5 *gorm.DB) *gorm.DB { // Level 6: receives from level 5
							return l5.Where("level6", 6)
						}(q3.Where("level5", 5))
					}().Where("merge", l3)
				}(q2.Where("level3", 3))
			}().Where("merge", l1)
		}(q1.Where("level1", 1))
	}().Find(nil)

	// All second branches - violations
	q1.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	q2.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	q3.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Stored Closure (User's test cases)
// =============================================================================

// storedClosureChain demonstrates stored closure returning a chain.
// The closure result flows to q2, so q2.Where() continues the same chain.
func storedClosureChain(db *gorm.DB) {
	q1 := db.Where("x", 1).Session(&gorm.Session{})

	// Stored closure (not IIFE) - same semantics as IIFE
	fn := func() *gorm.DB {
		return q1.Where("from closure", 1)
	}
	q2 := fn()         // q2 holds first branch from q1
	q2.Where("y", 2)   // Continues q2's chain (OK)
	q1 = q1.Where("z", 3)   // want `\*gorm\.DB instance reused after chain method`
}

// storedClosureReordered demonstrates order of calls with stored closure.
// [LIMITATION] SSA processing order differs from runtime order.
// At analysis time, closure body is processed first (q1.Where("from closure") is non-terminal),
// then q1.Where("z") is first terminal use, then q2.Where("y") is second terminal use.
// Ideally q1.Where("z") would be the violation, but current implementation reports on q2.Where("y").
func storedClosureReordered(db *gorm.DB) {
	q1 := db.Where("x", 1).Session(&gorm.Session{})

	fn := func() *gorm.DB {
		return q1.Where("from closure", 1) // Pollutes q1 (closure body processed first in SSA)
	}
	q2 := fn()
	q1 = q1.Where("z", 3) // want `\*gorm\.DB instance reused after chain method`
	q2.Where("y", 2) // OK: q2 is fresh root
}

// iifeStoredResult demonstrates IIFE result stored in variable.
func iifeStoredResult(db *gorm.DB) {
	q1 := db.Where("x", 1).Session(&gorm.Session{})

	// IIFE result stored
	q2 := func() *gorm.DB {
		return q1.Where("from iife", 1)
	}()
	q2.Where("y", 2)   // Continues q2's chain (OK)
	q1 = q1.Where("z", 3)   // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// DB INIT METHODS - Begin/Transaction (Immutable Source)
// =============================================================================

// beginReturnsImmutable demonstrates that Begin() returns an immutable source.
// Using tx (from Begin()) multiple times is safe - Begin() creates a new transaction.
func beginReturnsImmutable(db *gorm.DB) {
	tx := db.Begin()
	tx.Find(nil)
	tx.Count(nil) // Safe - tx is from Begin(), treated as immutable source
}

// beginChainedBecomesMutable demonstrates chaining after Begin() creates mutable.
func beginChainedBecomesMutable(db *gorm.DB) {
	tx := db.Begin().Where("x = ?", 1).Session(&gorm.Session{})
	tx.Find(nil)
	tx.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EVIL PATTERNS - Reassignment Edge Cases
// =============================================================================

// reassignInLoop demonstrates reassignment inside a loop.
// Each iteration creates a new mutable instance.
func reassignInLoop(db *gorm.DB, items []string) {
	var q *gorm.DB
	for _, item := range items {
		q = db.Where("name = ?", item).Session(&gorm.Session{})
		q.Find(nil)
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}
}

// reassignInLoopSafe demonstrates safe reassignment pattern in loop.
// Reassignment before each use prevents pollution carry-over.
func reassignInLoopSafe(db *gorm.DB, items []string) {
	var q *gorm.DB
	for _, item := range items {
		q = db.Where("name = ?", item)
		q.Find(nil)
		// No second use of same q - reassigned in next iteration
	}
}

// reassignConditionalPartial demonstrates partial reassignment in conditional.
// Only one branch reassigns - other branch uses polluted value.
func reassignConditionalPartial(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	if flag {
		q = db.Where("y = ?", 2) // Reassigns q in this branch only
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// reassignConditionalBoth demonstrates reassignment in both branches.
// Both branches reassign - should be safe.
func reassignConditionalBoth(db *gorm.DB, flag bool) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	if flag {
		q = db.Where("y = ?", 2)
	} else {
		q = db.Where("z = ?", 3)
	}

	q.Count(nil) // Safe - q reassigned in both branches
}

// reassignAfterPollutionSameValue demonstrates reassignment with same polluted source.
// Reassigning from same polluted chain is still unsafe.
func reassignAfterPollutionSameValue(db *gorm.DB) {
	base := db.Where("x = ?", 1).Session(&gorm.Session{})
	base.Find(nil) // Pollutes base

	q := base.Where("y = ?", 2) // want `\*gorm\.DB instance reused after chain method`
	q.Count(nil)                // OK: q is a fresh root
}

// reassignShadowing demonstrates variable shadowing vs reassignment.
// Inner q shadows outer q - they are different variables.
func reassignShadowing(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	q.Find(nil) // Pollutes outer q

	{
		q := db.Where("y = ?", 2).Session(&gorm.Session{}) // New variable (shadows)
		q.Find(nil)               // Pollutes inner q
		q.Count(nil)              // want `\*gorm\.DB instance reused after chain method`
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// reassignInClosure demonstrates reassignment inside closure.
func reassignInClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})
	q.Find(nil) // Pollutes q

	func() {
		q = db.Where("y = ?", 2) // Reassign in closure
	}()

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// reassignFromHelper demonstrates reassignment from helper function.
func reassignFromHelper(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	q = helperReturnsDB(db).Session(&gorm.Session{}) // Reassign from helper
	q.Find(nil)             // Pollutes new q
	q.Count(nil)            // want `\*gorm\.DB instance reused after chain method`
}

func helperReturnsDB(db *gorm.DB) *gorm.DB {
	return db.Where("from helper", 1)
}

// reassignNilThenUse demonstrates reassigning to nil then using.
func reassignNilThenUse(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	q = nil // Reassign to nil

	q = db.Where("y = ?", 2)
	q.Find(nil) // Safe - new instance
}

// reassignChainExtension demonstrates extending a chain after reassignment.
func reassignChainExtension(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	q = db.Where("y = ?", 2)
	q = q.Where("z = ?", 3).Session(&gorm.Session{}) // Extend the new chain
	q.Find(nil)             // Pollutes new q
	q.Count(nil)            // want `\*gorm\.DB instance reused after chain method`
}

// reassignMultipleTimes demonstrates multiple reassignments.
func reassignMultipleTimes(db *gorm.DB) {
	q := db.Where("a = ?", 1)
	q.Find(nil) // Pollutes first q

	q = db.Where("b = ?", 2)
	q.Find(nil) // Pollutes second q

	q = db.Where("c = ?", 3)
	q.Find(nil) // Pollutes third q

	q = db.Where("d = ?", 4) // Fresh assignment
	q.Count(nil)             // Safe - new instance
}

// reassignInSwitch demonstrates reassignment in switch statement.
// Only some branches reassign - default branch keeps polluted value.
func reassignInSwitch(db *gorm.DB, mode int) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	switch mode {
	case 1:
		q = db.Where("mode1", 1)
	case 2:
		q = db.Where("mode2", 2)
	default:
		// No reassignment in default - q is still polluted
	}

	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// reassignInSwitchAll demonstrates reassignment in all switch branches.
func reassignInSwitchAll(db *gorm.DB, mode int) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	switch mode {
	case 1:
		q = db.Where("mode1", 1)
	case 2:
		q = db.Where("mode2", 2)
	default:
		q = db.Where("default", 0)
	}

	q.Count(nil) // Safe - q reassigned in all branches
}

// reassignFromMethodValue demonstrates reassignment via method value result.
func reassignFromMethodValue(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	q.Find(nil) // Pollutes q

	where := db.Where
	q = where("y = ?", 2) // Reassign from method value
	q.Find(nil)           // Pollutes new q
	q.Count(nil)          // want `\*gorm\.DB instance reused after chain method`
}

// reassignDeferredUse demonstrates reassignment with deferred use.
// The defer evaluates q immediately - Count pollutes, then defer uses polluted q.
func reassignDeferredUse(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Find(nil) // want `\*gorm\.DB instance reused after chain method`

	q.Count(nil) // Pollutes q, defer will use this polluted q

	q = db.Where("y = ?", 2) // Reassignment doesn't affect deferred call (already captured)
}

// reassignPointerDeref demonstrates reassignment through pointer.
// [LIMITATION] Pointer dereference reassignment tracking not fully supported.
func reassignPointerDeref(db *gorm.DB) {
	q := db.Where("x = ?", 1)
	p := &q

	(*p).Find(nil) // Pollutes through pointer

	*p = db.Where("y = ?", 2) // Reassign through pointer

	// [LIMITATION] FALSE POSITIVE: Pointer reassignment creates new root tracking
	q.Find(nil)  // want `\*gorm\.DB instance reused after chain method`
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// EDGE CASES - Pointer Phi for traceAllPointerLoads coverage
// =============================================================================

// pointerPhiCase demonstrates pointer tracking through conditionally assigned pointer-to-pointer.
// Due to SSA's Alloc/Store/Load pattern for local variables, this doesn't create a Phi
// for the pointer itself, but exercises the traceAllAllocStores path.
func pointerPhiCase(db *gorm.DB, flag bool) {
	// Create two separate allocations
	var q1, q2 *gorm.DB
	q1 = db.Where("a", 1).Session(&gorm.Session{})
	q2 = db.Where("b", 2)

	// pp is a pointer-to-pointer
	var pp **gorm.DB
	if flag {
		pp = &q1 // Points to q1's storage
	} else {
		pp = &q2 // Points to q2's storage
	}

	// Dereference through conditionally assigned pointer
	(*pp).Find(nil) // Pollutes through pointer

	// q1 is detected because traceAllAllocStores finds the store
	q1.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	// q2 detection depends on SSA structure - may or may not be detected
	q2.Count(nil)
}

// =============================================================================
// SHOULD NOT REPORT - Pure method (gormreuse:pure directive on method)
// =============================================================================

// OrmWrapper is a wrapper type for testing pure methods.
type OrmWrapper struct{}

// GetDB is a pure method that returns a new *gorm.DB.
//
//gormreuse:pure // want `unused gormreuse:pure directive`
func (o *OrmWrapper) GetDB() *gorm.DB {
	return DB.WithContext(nil)
}

// pureMethodUsage demonstrates that user-defined pure method return values are MUTABLE.
// Pure methods only guarantee they don't pollute arguments - return values may be mutable.
func pureMethodUsage() {
	wrapper := &OrmWrapper{}
	db := wrapper.GetDB().Session(&gorm.Session{})
	db.Find(nil)
	db.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Where-only patterns (no finisher at violation point)
// These test that detection doesn't depend on isTerminal logic.
// Even without Find/Count/etc, using a mutable value twice is a violation.
// =============================================================================

// whereOnlyBasic demonstrates that violation is detected even without finisher.
// The second branch ends with Where, not Find.
func whereOnlyBasic(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	q.Where("a").Find(nil) // First branch - pollutes q

	q = q.Where("b") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyChain demonstrates chained Where without finisher.
func whereOnlyChain(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	q.Find(nil) // First branch - pollutes q

	q.Where("a").Where("b").Order("c") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyClosure demonstrates closure pollution then Where-only outside.
func whereOnlyClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	func() {
		q.Find(nil) // Pollutes q inside closure
	}()

	q = q.Where("outside") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyIIFE demonstrates IIFE pollution then Where-only outside.
func whereOnlyIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	_ = func() *gorm.DB {
		return q.Where("from iife")
	}().Find(nil) // First branch (IIFE chain)

	q = q.Where("outside") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyLoop demonstrates loop pollution with Where-only.
func whereOnlyLoop(db *gorm.DB, items []int) {
	q := db.Where("x = ?", 1)

	for range items {
		q = q.Where("in loop") // want `\*gorm\.DB instance reused after chain method`
	}
}

// whereOnlyConditional demonstrates conditional with Where-only violation.
func whereOnlyConditional(db *gorm.DB, flag bool) {
	q := db.Where("base").Session(&gorm.Session{})

	if flag {
		q.Find(nil) // First branch
	} else {
		q.Count(nil) // First branch (mutually exclusive)
	}

	q = q.Where("after conditional") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyDefer demonstrates defer with Where-only.
func whereOnlyDefer(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	defer q.Where("deferred") // want `\*gorm\.DB instance reused after chain method`

	q.Find(nil)
}

// whereOnlyGoroutine demonstrates goroutine with Where-only.
// Note: Both goroutine closure and main code pollute q - analyzer detects reuse.
func whereOnlyGoroutine(db *gorm.DB) {
	q := db.Where("x = ?", 1)

	go func() {
		q = q.Where("in goroutine")
	}()

	q.Find(nil) // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyStoredClosure demonstrates stored closure with Where-only violation.
func whereOnlyStoredClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	fn := func() {
		q.Find(nil) // Pollutes q
	}
	fn()

	q = q.Where("after stored closure") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyStoredClosureReturn demonstrates stored closure returning chain.
func whereOnlyStoredClosureReturn(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	fn := func() *gorm.DB {
		return q.Where("from closure")
	}
	_ = fn().Find(nil) // First branch

	q = q.Where("after") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyIIFEStored demonstrates stored IIFE result with Where-only.
// IIFE creates first branch from q (stored in q2), so q.Where is second branch.
func whereOnlyIIFEStored(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	q2 := func() *gorm.DB {
		return q.Where("from iife") // First branch from q
	}()

	q2.Where("use stored") // Continues q2's chain (OK)
	q = q.Where("original")    // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyBoundMethod demonstrates bound method with Where-only.
func whereOnlyBoundMethod(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	where := q.Where
	where("bound method call") // First use - pollutes q

	q = q.Where("after bound") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyNestedIIFE demonstrates nested IIFE with Where-only.
func whereOnlyNestedIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	_ = func() *gorm.DB {
		return func() *gorm.DB {
			return q.Where("nested")
		}()
	}().Find(nil) // First branch (entire nested IIFE chain)

	q = q.Where("after nested") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyIIFEChainContinued demonstrates IIFE chain with Where continuation.
func whereOnlyIIFEChainContinued(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	_ = func() *gorm.DB {
		return q.Where("iife inner")
	}().Where("chained after iife").Find(nil) // First branch

	q = q.Where("second branch") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyDoubleIIFE demonstrates two IIFEs with Where-only.
func whereOnlyDoubleIIFE(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	_ = func() *gorm.DB {
		return q.Where("first iife")
	}().Find(nil) // First branch

	_ = func() *gorm.DB {
		return q.Where("second iife") // want `\*gorm\.DB instance reused after chain method`
	}()
}

// whereOnlyStructFieldClosure demonstrates struct field with closure and Where-only.
func whereOnlyStructFieldClosure(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	type holder struct {
		fn func()
	}
	h := holder{
		fn: func() {
			q.Find(nil) // Pollutes q
		},
	}
	h.fn()

	q = q.Where("after struct field closure") // want `\*gorm\.DB instance reused after chain method`
}

// whereOnlyMultipleBranches demonstrates multiple Where-only branches.
func whereOnlyMultipleBranches(db *gorm.DB) {
	q := db.Where("x = ?", 1).Session(&gorm.Session{})

	q.Where("branch1").Find(nil) // First branch

	q = q.Where("branch2") // want `\*gorm\.DB instance reused after chain method`
	q = q.Where("branch3") // want `\*gorm\.DB instance reused after chain method`
	q = q.Where("branch4") // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// Chaining Without Reassignment (README [!IMPORTANT] examples)
// =============================================================================

// chainingWithoutReassignmentViolation demonstrates the violation pattern
// from README: each separate statement creates a branch from q.
func chainingWithoutReassignmentViolation(db *gorm.DB) {
	q := db.Where("base")
	q = q.Where("a")     // first branch - OK
	q = q.Where("b")     // want `\*gorm\.DB instance reused after chain method`
	q.Find(nil)      // want `\*gorm\.DB instance reused after chain method`
}

// chainingWithReassignmentSafe demonstrates the solution: reassign each step.
// Each reassignment creates a new SSA value, so only the final Find is a branch.
func chainingWithReassignmentSafe(db *gorm.DB) {
	q := db.Where("base")
	q = q.Where("a")
	q = q.Where("b")
	q.Find(nil) // OK - first branch from final q
}

// singleChainedExpressionSafe demonstrates the other solution: single expression.
// The entire chain is one expression, so it's a single branch.
func singleChainedExpressionSafe(db *gorm.DB) {
	db.Where("base").Where("a").Where("b").Find(nil) // OK - single chain
}

// =============================================================================
// EVIL PATTERNS - Complex Phi Patterns (Mixed Immutability)
// =============================================================================

// phiOneHasSession demonstrates Phi where one branch already has Session.
// Only the mutable branch should get Session added.
func phiOneHasSession(db *gorm.DB, cond bool) {
	var q *gorm.DB
	if cond {
		q = db.Where("branch1", 1).Session(&gorm.Session{}) // Already immutable
	} else {
		q = db.Where("branch2", 2).Session(&gorm.Session{}) // Needs Session
	}

	q.Find(nil)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// phiSessionInMiddle demonstrates Session in the middle of a chain.
// Should detect Session even when followed by more chain methods.
func phiSessionInMiddle(db *gorm.DB, cond bool) {
	var q *gorm.DB
	if cond {
		q = db.Where("branch1", 1).Session(&gorm.Session{}).Where("after") // Immutable (Session in chain)
	} else {
		q = db.Where("branch2", 2).Session(&gorm.Session{}) // Needs Session
	}

	q.Find(nil)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// phiThreeBranchesMiddleImmutable demonstrates if/else if/else with middle branch immutable.
// This is the "harassment pattern" - only 1st and 3rd branches need Session.
func phiThreeBranchesMiddleImmutable(db *gorm.DB, mode int) {
	var q *gorm.DB
	if mode == 1 {
		q = db.Where("branch1", 1).Session(&gorm.Session{}) // Needs Session
	} else if mode == 2 {
		q = db.Where("branch2", 2).Session(&gorm.Session{}) // Already immutable
	} else {
		q = db.Where("branch3", 3).Session(&gorm.Session{}) // Needs Session
	}

	q.Find(nil)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// phiSwitchMixedSession demonstrates switch with mixed Session.
// Only cases without Session should get it added.
func phiSwitchMixedSession(db *gorm.DB, mode int) {
	var q *gorm.DB
	switch mode {
	case 1:
		q = db.Where("case1", 1).Session(&gorm.Session{}) // Needs Session
	case 2:
		q = db.Where("case2", 2).Session(&gorm.Session{}) // Already immutable
	case 3:
		q = db.Where("case3", 3).Session(&gorm.Session{}) // Needs Session
	default:
		q = db.Where("default").Session(&gorm.Session{}) // Needs Session
	}

	q.Find(nil)
	q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// phiSwitchAllImmutable demonstrates switch where all cases are immutable.
// No Session should be added (already safe).
func phiSwitchAllImmutable(db *gorm.DB, mode int) {
	var q *gorm.DB
	switch mode {
	case 1:
		q = db.Where("case1", 1).Session(&gorm.Session{})
	case 2:
		q = db.Where("case2", 2).WithContext(nil)
	default:
		q = db.Where("default").Debug()
	}

	q.Find(nil)
	q.Count(nil) // OK: all branches immutable
}

// =============================================================================
// FIX GENERATOR EDGE CASE - Callback wrapper functions
// These test cases verify that Session is NOT added to wrapper function calls
// =============================================================================

// wrapperFunc is a helper that takes a callback (like t.Run or Transaction).
func wrapperFunc(fn func()) bool {
	fn()
	return true
}

// callbackViolationInWrapper demonstrates violation inside callback.
// Session should be added to `db.Where("x")` call, NOT to wrapperFunc call.
func callbackViolationInWrapper(db *gorm.DB) {
	wrapperFunc(func() {
		q := db.Where("x").Session(&gorm.Session{})
		q.Find(nil)
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	})
}

// callbackMultipleViolationsInWrapper demonstrates multiple violations.
func callbackMultipleViolationsInWrapper(db *gorm.DB) {
	wrapperFunc(func() {
		q := db.Where("base").Session(&gorm.Session{})
		q.Find(nil)
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		q.First(nil) // want `\*gorm\.DB instance reused after chain method`
	})
}

// callbackNestedWrappers demonstrates nested wrapper functions.
func callbackNestedWrappers(db *gorm.DB) {
	wrapperFunc(func() {
		wrapperFunc(func() {
			q := db.Where("nested").Session(&gorm.Session{})
			q.Find(nil)
			q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
		})
	})
}

// =============================================================================
// SHOULD REPORT - Conditional Struct Field Assignment (traceAllFieldStores test)
// =============================================================================
//
// These tests verify that FindAllMutableRoots correctly finds all possible roots
// when a struct field is conditionally assigned from different sources.

// conditionalFieldAssignHolderForTest is a helper struct for field assignment tests.
type conditionalFieldAssignHolderForTest struct {
	db *gorm.DB
}

// conditionalFieldAssignOnePolluted demonstrates conditional field assignment
// where one branch assigns a polluted value.
// The linter should detect this because q1 (polluted) may be used via h.db.
func conditionalFieldAssignOnePolluted(db *gorm.DB, cond bool) {
	q1 := db.Where("a").Session(&gorm.Session{})
	q2 := db.Where("b")
	q1.Find(nil) // Pollute q1

	h := &conditionalFieldAssignHolderForTest{}
	if cond {
		h.db = q1 // Branch 1: assigns polluted q1
	} else {
		h.db = q2 // Branch 2: assigns clean q2
	}
	// h.db may be q1 (polluted) or q2 (clean)
	// Should detect pollution from q1
	h.db.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// conditionalFieldAssignOnePollutedReverse demonstrates the same pattern
// but with branches in reverse order. This may expose ordering issues in
// traceFieldStore which returns the first Store found.
// [BUG DETECTOR] If this test passes but conditionalFieldAssignOnePolluted fails,
// or vice versa, there's an ordering bug in traceFieldStore.
func conditionalFieldAssignOnePollutedReverse(db *gorm.DB, cond bool) {
	q1 := db.Where("a")
	q2 := db.Where("b").Session(&gorm.Session{})
	q2.Find(nil) // Pollute q2 (reversed from above)

	h := &conditionalFieldAssignHolderForTest{}
	if cond {
		h.db = q1 // Branch 1: assigns clean q1
	} else {
		h.db = q2 // Branch 2: assigns polluted q2
	}
	// h.db may be q1 (clean) or q2 (polluted)
	// Should detect pollution from q2
	h.db.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// conditionalFieldAssignBothPolluted demonstrates conditional field assignment
// where both branches assign polluted values.
func conditionalFieldAssignBothPolluted(db *gorm.DB, cond bool) {
	q1 := db.Where("a")
	q2 := db.Where("b").Session(&gorm.Session{})
	q1.Find(nil) // Pollute q1
	q2.Find(nil) // Pollute q2

	h := &conditionalFieldAssignHolderForTest{}
	if cond {
		h.db = q1 // Branch 1: polluted
	} else {
		h.db = q2 // Branch 2: also polluted
	}
	// h.db may be q1 or q2, both are polluted
	h.db.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// conditionalFieldAssignThenUseInBothBranches demonstrates field assignment
// and use happening in both branches independently.
func conditionalFieldAssignThenUseInBothBranches(db *gorm.DB, cond bool) {
	h := &conditionalFieldAssignHolderForTest{}
	if cond {
		h.db = db.Where("a").Session(&gorm.Session{})
	} else {
		h.db = db.Where("b")
	}
	h.db.Find(nil) // First use - OK
	h.db.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// =============================================================================
// SHOULD REPORT - Closure captures Phi (traceAllFreeVar test)
// =============================================================================
//
// These tests verify that when a closure captures a Phi value (from conditional
// assignment), FindAllMutableRoots correctly finds all possible roots.

// closureCapturesPhi demonstrates a closure capturing a Phi value.
// The closure's FreeVar should trace through to ALL branches of the Phi.
func closureCapturesPhi(db *gorm.DB, cond bool) {
	var q *gorm.DB
	if cond {
		q = db.Where("a")
	} else {
		q = db.Where("b")
	}
	q.Find(nil) // Pollute (both branches get polluted because Phi merges them)

	fn := func() {
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}
	fn()
}

// closureCaputresPhiOnePolluted demonstrates closure with Phi where only one branch is polluted.
// [BUG DETECTOR] This test exposes if traceAll for FreeVar only returns one root.
func closureCaputresPhiOnePolluted(db *gorm.DB, cond bool) {
	q1 := db.Where("a")
	q2 := db.Where("b")
	q1.Find(nil) // Pollute q1 only

	var q *gorm.DB
	if cond {
		q = q1 // Branch 1: polluted
	} else {
		q = q2 // Branch 2: clean
	}
	// q is now a Phi of [q1, q2]

	fn := func() {
		// FreeVar captures the Phi
		// Should detect pollution from q1
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}
	fn()
}

// closureCaputresPhiOnePollutedReverse demonstrates the reverse ordering.
func closureCaputresPhiOnePollutedReverse(db *gorm.DB, cond bool) {
	q1 := db.Where("a")
	q2 := db.Where("b")
	q2.Find(nil) // Pollute q2 only (reversed)

	var q *gorm.DB
	if cond {
		q = q1 // Branch 1: clean
	} else {
		q = q2 // Branch 2: polluted
	}
	// q is now a Phi of [q1, q2]

	fn := func() {
		// FreeVar captures the Phi
		// Should detect pollution from q2
		q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
	}
	fn()
}

// =============================================================================
// Bound Method / Go / Defer with Phi receiver - FindAllMutableRoots coverage
// =============================================================================

// boundMethodWithPhiOnePolluted tests bound method call where one branch of Phi is polluted.
// This should detect that q2 branch is already polluted when using bound method on merged Phi.
func boundMethodWithPhiOnePolluted(db *gorm.DB, flag bool) {
	var q *gorm.DB
	if flag {
		q = db.Where("a")
		q.Find(nil) // pollutes q from this branch
	} else {
		q = db.Where("b")
	}
	// q is Phi(q_polluted, q_clean)
	find := q.Find // Bound method
	find(nil)      // want `\*gorm\.DB instance reused after chain method`
}

// [LIMITATION] boundMethodWithPhiOnePollutedReverse tests bound method with reversed branch order.
// SSA block ordering may differ from source order. When pollution occurs in
// a later-numbered block (else branch) that executes before a bound method call
// in an earlier-numbered block (merge block), detection may fail.
func boundMethodWithPhiOnePollutedReverse(db *gorm.DB, flag bool) {
	var q *gorm.DB
	if flag {
		q = db.Where("a")
	} else {
		q = db.Where("b")
		q.Find(nil) // pollutes q from this branch
	}
	// q is Phi(q_clean, q_polluted)
	find := q.Find // Bound method
	find(nil)      // SHOULD want violation, but SSA block order prevents detection
}

// goStatementWithPhiOnePolluted tests go statement where one branch of Phi is polluted.
func goStatementWithPhiOnePolluted(db *gorm.DB, flag bool) {
	var q *gorm.DB
	if flag {
		q = db.Where("a")
		q.Find(nil) // pollutes q from this branch
	} else {
		q = db.Where("b")
	}
	// q is Phi(q_polluted, q_clean)
	go q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// goStatementWithPhiOnePollutedReverse tests go with reversed branch order.
func goStatementWithPhiOnePollutedReverse(db *gorm.DB, flag bool) {
	var q *gorm.DB
	if flag {
		q = db.Where("a")
	} else {
		q = db.Where("b")
		q.Find(nil) // pollutes q from this branch
	}
	// q is Phi(q_clean, q_polluted)
	go q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// deferStatementWithPhiOnePolluted tests defer where one branch of Phi is polluted.
func deferStatementWithPhiOnePolluted(db *gorm.DB, flag bool) {
	var q *gorm.DB
	if flag {
		q = db.Where("a")
		q.Find(nil) // pollutes q from this branch
	} else {
		q = db.Where("b")
	}
	// q is Phi(q_polluted, q_clean)
	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}

// deferStatementWithPhiOnePollutedReverse tests defer with reversed branch order.
func deferStatementWithPhiOnePollutedReverse(db *gorm.DB, flag bool) {
	var q *gorm.DB
	if flag {
		q = db.Where("a")
	} else {
		q = db.Where("b")
		q.Find(nil) // pollutes q from this branch
	}
	// q is Phi(q_clean, q_polluted)
	defer q.Count(nil) // want `\*gorm\.DB instance reused after chain method`
}
